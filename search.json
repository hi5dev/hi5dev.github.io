{"entries":[{"title":null,"url":"/search/","date":null,"categories":[],"body":""},{"title":null,"url":"/contact/","date":null,"categories":[],"body":"Contact Hello, allow me to introduce myself. My name is Travis Haynes . I am a full-time Ruby developer . I started Hi5 Development in 2009. I am available for short or long-term consulting with solid experience in Ruby, e-commerce, and Rails. If you have a project and you think I can do it, let me know. I will be happy to review your project’s requirements and get back to you with a proposal. You can contact me using the form below, or email me at travis@hi5dev.com . Name: Email: Website: Message: Submit "},{"title":null,"url":"/","date":null,"categories":[],"body":""},{"title":"Jekyll","url":"/code/2012/12/05/jekyll/","date":"2012-12-05 00:00:00 -0700","categories":["code"],"body":"I have decided to use github pages to manage my website. It’s a fantastic setup; ideal for a programmer. It gives me complete control over my website, at the same time as keeping it simple, and easy to manage. The main reason I’m using github pages is because it comes with Jekyll built in. And having the entire website kept in a git repository means I can at anytime pull the entire website off of one server, and push it onto a new one without having to muck about on a server. It also makes it a whole lot easier to back up the website. All I have to do is push the source code into another repository after I push it to where it’s published live. "},{"title":"Foundation 3","url":"/code/2012/12/11/foundation-3/","date":"2012-12-11 00:00:00 -0700","categories":["code"],"body":"I’ve decided to build my website using Foundation 3 , which claims to be “the most advanced responsive front-end framework in the world.” So far the results have been pretty clean, from a developer’s point of view, anyway, and I am actually very impressed. I’m thinking of using this framework to develop a Shopify theme. I’ve attempted to build a Shopify theme in the past using Twitter’s Bootstrap CSS framework, but I found it rather bulky, and difficult to work with, to be honest. So I never really got too far with it. What I like the most about this CSS framework is how clean the responsive layout is, and how smooth it transitions when you resize the browser. Go ahead and try resizing your browser now to watch how quickly, and smoothly it makes the transition. The Twitter Bootstrap responsive theme relies on JavaScript, which makes it really slow, at least on my computer, when resizing the window. "},{"title":"SimpleForm","url":"/code/2012/12/12/simple-form/","date":"2012-12-12 00:00:00 -0700","categories":["code"],"body":"Since I’m hosting my website on Github I have to use a 3rd party service for collecting data from HTML forms. I almost opted out of a static website content generator (Jekyll in this case) because of the bad experiences I have had in the past with online form tools. Most of the online form tools want to include some sort of branding on your form, and require that you insert a script tag where you want the form to go. This causes all kinds of issues, not the least of which is the lack of being able to modify the form’s styling to match your existing website since most of them slap the form into your website in an embedded iframe. Fortunately I discovered a really simple hosted form tool called SimpleForm that doesn’t care about branding, and doesn’t use iframes and script tags. All it does is provide you with a place to send your form data to. That’s it. "},{"title":"Multiple Route Files in Rails","url":"/code/2012/12/17/multiple-route-files-in-rails/","date":"2012-12-17 00:00:00 -0700","categories":["code"],"body":"Lately I have been working on a Rails project with routes that have been getting more and more complicated. The project has three different user types. Each user has routes that are only visible when they’re signed in, plus public routes, with some that are only visible when certain users are signed in, and some of the routes are repeated under different namespaces, or with different constraints. Since the routes file has been expanding over time, I decided that it would be best to split it up into smaller, easier to read and manage files. After doing a search on multiple rails route files to find out how to configure my application for this, I found this simple one line solution that you can add to your config/application.rb file in a Rails 3.2 or higher application: 1 config . paths [ \"config/routes\" ] += Dir [ Rails . root . join ( \"config\" , \"routes\" , \"*.rb\" ) ] What that does is tell your application to use any file located in config/routes as a routing file. However, there were a couple of drawbacks I found in using this method. First, since config/application.rb is only loaded once when your application boots, if you were to add, rename, or delete any files in the config/routes directory, you would need to restart your application for the changes to become effective. But the biggest issue, and the reason I chose not to use this method, is that it does not allow you to specify the order in which the routes are loaded. And for the application I’m working on the routes need to be loaded in a specific order. So I ended up having to write my own method of using multiple route files, which is in the form of a very simple routing extension that looks like this: 1 # File: config/initializers/routing_extensions.rb 2 class ActionDispatch :: Routing :: Mapper 3 def draw ( * names ) 4 names . each do | name | 5 file = Rails . root . join ( \"config\" , \"routes\" , \" #{ name . to_s } .rb\" ) 6 code = File . read ( file ) 7 eval ( code ) 8 end 9 end 10 end Now I can specify the exact order the external route files should be loaded in, when the routes should be loaded, and even use them more than once. For example, here is a very small portion of the routes in the application I am working on right now: 1 # File: config/routes.rb 2 AppName :: Application . routes . draw do 3 devise_for :admin , :user 4 5 authenticated ( :user ) { draw :authenticated } 6 7 authenticated ( :admin ) do 8 namespace ( :admin ) { draw :authenticated } 9 end 10 11 draw :public 12 end 1 # File: config/routes/authenticated.rb 2 resource :dashboard , :only => [ :show ] 3 resource :preferences , :only => [ :edit , :update ] 4 root :to => \"dashboards#show\" 1 # File: config/routes/public.rb 2 get \"/about\" => \"about#show\" 3 root :to => \"about#show\" "},{"title":"ActiveRecord::Session::Store","url":"/2013/01/01/active-record-session-store/","date":"2013-01-01 00:00:00 -0700","categories":[],"body":"Recently I ran into a cookie overflow issue when using the Sidekiq gem for background processing. To solve the issue, I had to abandon using cookies for session storage, and instead use the database for sessions. It’s very easy to set up, and the instructions can be found in any Rails app in the config/initializers/session_store.rb file. Something that isn’t outlined in the initializer, however, is that if you also create a Session model, but instead of descending from ActiveRecord::Base , descend from ActiveRecord::Session::Store , you can access your app’s sessions from anywhere in your application: 1 # File: app/models/session.rb 2 class Session < ActiveRecord :: Session :: Store ; end The Session object will behave like any other ActiveRecord model, with the exception of the #data method, which will return a Hash object. Here’s an example of how you could use this to broadcast a message to all your site’s current visitors: 1 Session . all . each do | session | 2 session . data [ 'flash' ] ||= ActionDispatch :: Flash :: FlashHash . new 3 session . data [ 'flash' ][ :alert ] = 'Server going down in 10 minutes for scheduled maintenance.' 4 session . save! 5 end You could even use it to display random site promotions. For example, using the clockwork gem, you could do this: 1 # File: lib/promotions.rb 2 require 'clockwork' 3 require 'config/boot' 4 require 'config/environment' 5 6 every ( 1 . minute , 'random.promos' ) do 7 Session . all . each do | session | 8 promo = Promo . all . sample 9 10 session [ 'flash' ] ||= ActionDispatch :: Flash :: FlashHash . new 11 session [ 'flash' ][ :promo ] = promo . call_to_action 12 session . save! 13 end 14 end 1 # File: app/views/application.html.erb 2 < % if flash [ :promo ]. present? %> 3 <div id=\"promo\"> <%= raw flash [ :promo ] %></div> 4 < % end %> Now the next time your site’s current visitors visit a new page they’ll be presented with the promotion, while any new visitors won’t see any promos until they’ve been browsing your site for at least 1 minute. "},{"title":"A Simple Rails CMS","url":"/2013/01/09/simple-rails-cms/","date":"2013-01-09 00:00:00 -0700","categories":[],"body":"If you’re building a website, you’re no doubt going to want to add some dynamic content to it. In Ruby on Rails, this is a surprisingly easy task and can be set up in just a few minutes. No gems required. To get started, first set up a Contents model: rails g contents slug:string format:string title:string author:string body:text Then modify the migration file that was created so it includes a default value for :format and has a unique index for :slug : 1 # File: db/migrate/*_create_contents.rb 2 3 class CreateContents < ActiveRecord :: Migration 4 def change 5 create_table :contents do | t | 6 t . string :slug 7 t . string :format , default : \"html\" 8 t . string :title 9 t . string :author 10 t . text :body 11 t . timestamps 12 end 13 14 add_index :contents , :slug , unique : true 15 end 16 end Now configure the Content model so it parameterizes the title into a slug, which is what we’ll be using for the URL to display the content. You’ll also need to set up the accessible fields, and validations: 1 # File: app/models/content.rb 2 3 class Content < ActiveRecord :: Base 4 attr_accessible :title , 5 :body , 6 :author , 7 :format 8 9 validates_presence_of :title , 10 :format , 11 :slug 12 13 before_validation do 14 self . slug = self . title . parameterize 15 end 16 17 def to_param 18 self . slug 19 end 20 end Next create a controller that will render the requested Content : 1 # File: app/controllers/contents_controller.rb 2 3 class ContentsController < ApplicationController 4 def show 5 # Get the ID of the page being requested, defaulting to 'home' 6 @id = params . fetch ( :id , 'home' ) 7 8 # Get the format of the requested content 9 @format = params . fetch ( :format , 'html' ) 10 11 # Find the content by its slug and format 12 @content = Content . find_by_slug_and_format! ( @id , @format ) 13 14 # Render the content inline 15 render inline : @content . body 16 end 17 end Configure your app’s routes: 1 # File: config/routes.rb 2 3 MyApp :: Application . routes . draw do 4 root to : \"contents#show\" 5 get \"contents/*id\" => \"contents#show\" 6 end Fire up the rails console and create some default content: 1 Content . create! format : 'html' , title : 'Home Page' , body : '<h1><%= @content.title %></h1>' Now when you visit your app in the browser you’ll be presented with content that was pulled from the database and rendered by your application. This is just a very brief example of how to set this up. There’s a lot more to take into consideration. For example, since you can execute ERB code in your site’s dynamic content using this method, you’ll need to take the necessary security measures in the controller to ensure that malicious code or rouge scripts could not be executed. Which means that, unless you are the only person who will be editing your site’s content, you will probably want to use something other than Rails default template renderer, such as Shopify’s Liquid template language, since it leaves your site open to too many vulnerabilities otherwise. You’ll also need to set up the controller to edit the content from within the browser. I left that out of the above example for the sake of brevity, since it is very basic Rails code. "},{"title":"How to Create A Swap File without a Partition","url":"/code/2013/11/25/temporary-linux-swap/","date":"2013-11-25 00:00:00 -0700","categories":["code"],"body":"So this will be a very short article, but it is something I find very useful from time-to-time, especially when compiling code on a cheap cloud server with very limited resources. Here’s how to enable a temporary swap file without having to have a partition dedicated to it: 1 sudo dd if = /dev/zero of = /swap bs = 1M count = 2048 2 sudo mkswap /swap 3 sudo swapon /swap And that’s it! Just change the 2048 in count=2048 to however many kilobytes you’d like the swap file to be. "},{"title":"Get Your Own Free Private Gem Server","url":"/code/2013/12/05/free-private-gem-server-how-to/","date":"2013-12-05 00:00:00 -0700","categories":["code"],"body":"Using Heroku you can privately host your gems in just a couple of minutes. Here’s how. Start by creating an empty project folder, and add a Gemfile with only the source and ruby version: 1 # File: Gemfile 2 source 'https://rubygems.org' 3 ruby '2.0.0' Then run bundle to generate Gemfile.lock . Next, create a Procfile with the following content: 1 # File: Procfile 2 web: gem server -p $PORT Then set up Git: 1 $ git init . 2 $ git add . 3 $ git commit -m Initial commit Create a new Heroku app and push your application to Heroku: 1 $ heroku create 2 $ git push heroku master Then launch your new privately hosted gem server in the browser: 1 $ heroku open And just like that you have your very own private gem server. Now let’s push a gem to the server. First you’ll want to create a .gitignore file and add .bundle to it so we don’t end up pushing our local Bundler settings to heroku: 1 $ echo \".bundle\" >> .gitignore 2 $ git add .gitignore 3 $ git commit -m Ignoring the .bundle path Next you’ll need a vendor/cache folder. This is where you’ll place your private .gem files. So go ahead and create that folder now, and copy your gem file into it. 1 $ mkdir vendor 2 $ mkdir vendor/cache 3 $ cp my.gem vendor/cache # replace 'my.gem' with your actual gem file This is where things can get a little tricky. In order for us to push our gem to Heroku, we need to first run bundle install . However since our gem is going to be privately hosted, Bundler will try and fail to download it from rubygems.org. So we need to cache the gem first so it doesn’t try to download it. Ironically, the way we do that is by using the --no-cache flag. Then you’ll need to run bundle package --all to vendor your gem’s dependencies along with the gem: 1 $ bundle install --no-cache 2 $ bundle package --all Using bundle --no-cache tells Bundler that the .gem files have already been copied into the vendor/cache folder, and it will install those instead of connecting to rubygems.org. bundle package --all downloads the missing dependencies and copies their .gem files into the vendor/cache folder, thus completing the installation. It’s a bit confusing, but in the end it’s really only this three step process: Copy your private gem’s .gem file into vendor/cache Run bundle install --no-cache Run bundle package --all Then of course you’ll need to push those files to Heroku: 1 $ git add . 2 $ git commit -m Installed my private gem 3 $ git push heroku master Refresh your browser, and you’ll notice that your gem will now be listed. Now all you have to do to install the private gem in your application is add the URL to your Heroku app that’s hosting the gems to your Gemfile. For example: 1 # File myapp/Gemfile 2 source 'https://rubygems.org' 3 source 'http://private-gem-server.herokuapp.com' 4 5 gem 'my_private_app' "},{"title":"Using Foreman with Jekyll","url":"/jekyll/2014/06/13/using-foreman-with-jekyll/","date":"2014-06-13 12:05:36 -0600","categories":["jekyll"],"body":"When building a website with Jekyll, you might want the site to automatically rebuild when you make a change. You can do that with the jekyll build --watch command. Then of course you’ll want to serve the website so you can preview it in the browser. For that there’s the jekyll serve command. Running both commands at the same time requires opening separate terminal tabs. This can be a little bit frustrating. Especially when you start adding more features to your site. For example, if you want to use compass to compile SASS, you’ll need to open a 3rd tab to run compass watch . Doing this over and over again every time you want to edit your site can become a little tedious. Each time you’ll have to open at least two tabs, and remember which commands to run to get things started. And, if you haven’t worked on the site for a while, you might not remember all the components you’re using. Fortunately there’s an awesome gem called Foreman that can help you out with this. Here’s how to get it up and running with Jekyll. First, install the gem: $ gem install foreman Then, create a new file called Procfile in the root of your Jekyll project folder, and add the tasks you want running in parallel. Using the three tasks mentioned above as an example, your Procfile might look something like this: build : jekyll build --watch server : jekyll serve compass : compass watch To start all the processes in parallel, just run: $ foreman start Now you can manage and monitor all the processes in just one tab. Pressing CTRL+C will automatically send the KILL signal to every task for you. "},{"title":"Flash Marketing with Rails","url":"/rails/2014/06/16/flash_marketing_with_rails/","date":"2014-06-16 00:00:00 -0600","categories":["rails"],"body":"In a previous article , I talked about how you can use ActiveRecord session store to display promotions to your site’s visitors. Since that article was written, the ActiveRecord session store code has been refactored from Rails into its own gem, along with a few other changes that make the code incompatible with Rails 4 or higher. This is an update to that article, with a more complete tutorial. You can find the code for this article hosted on Github here . Getting Started To demonstrate this concept, let’s start by creating a new Rails application: $ rails new flash_marketing $ cd flash_marketing $ rake db:create Next, install activerecord-session_store : $ echo \"gem 'activerecord-session_store'\" >> Gemfile $ bundle $ rails g active_record:session_migration $ rake db:migrate Then edit config/initializers/session_store.rb and update it to the following: Rails . application . config . session_store :active_record_store Custom Session Model Now we can create a Session model that descends from ActiveRecord::SessionStore::Session . This will allow us to access every user’s session outside of the scope of the current user. Create app/models/session.rb and add the following content: class Session < ActiveRecord :: SessionStore :: Session end Normally we can only access a single user’s session data in the views or controllers. Using this model we have access to every user’s session, not just the current user, and from anywhere in our application. This includes background processes, which is what we will be using later on in this tutorial. Flash Messages Next, we need to be able to communicate with our site’s users. For that we’ll be taking advantage of Rails’ built in flash notification system. Let’s begin by adding a flash method to our Session model: class Session < ActiveRecord :: SessionStore :: Session def flash ( id , msg ) data [ 'flash' ] ||= { 'flashes' => {}, 'discard' => [] } data [ 'flash' ][ 'flashes' ][ id . to_sym ] = msg end end Now we can display flash messages to any of our site’s visitors. Just keep in mind that we’re not actually using ActionDispatch::Flash , which is what is used in the controllers. Next, let’s update the application’s layout to display flash messages. Add these lines to app/views/application.html.erb somewhere in the body: <% flash . each do | id , msg | %> <%= content_tag :div , msg , class : \"flash_ #{ id } \" %> <% end %> See it in Action So we can actually test this out, let’s remove the default Rails view by adding our own home page: $ rails g controller home show And then add that as our root path in config/routes.rb : Rails . application . routes . draw do root to : 'home#show' end To see it action, open up the application in your browser. Doing so will automatically create a new session record. Next, open a Rails console so you can see what’s going on: session = Session . first # => #<Session id: 1, session_id: \"f28ae9f7dd2066023be808c3b337e390\", data: \"BAh7BkkiEF9jc3JmX3Rva2VuBjoGRUZJIjFZYnFUb25sSlFXVV...\", created_at: \"2014-06-16 19:49:07\", updated_at: \"2014-06-16 19:49:07\"> If you inspect session.data , you’ll notice that it returns a Hash: session . data # => {\"_csrf_token\"=>\"YbqTonlJQWUQKTU/jLQFZVha7EiqN+uFlGO8g5nFgkg=\"} This is because it’s automatically serialized for you on the fly. Basically session.data can be treated the same as the session variable in a controller or view, except that you’ll have to call session.save to persist the data. Go ahead and try it out now by calling our custom flash method: session . flash :notice , \"hello world\" session . save Now refresh your browser, and you’ll see the message appear. Refresh it again, and it won’t appear twice, just like any normal flash message. Promotions Let’s put this feature to use by creating a Promotion model that we can use to display promotions to our site’s visitors. $ rails g model promotion name call_to_action:string active:boolean $ rake db:migrate The call_to_action will be the message displayed to the user. Setting active to false will disable the promotion. You can, of course, customize it however you’d like. For example, you might want to have a start and end date, or some prerequisites for targeting specific visitors. For this example we’re keeping it purposefully simple. Let’s seed in a couple promotions. Add the following content to db/seeds.rb : Promotion . create! ( :name => \"Clearance\" , :call_to_action => \"Save up to 90% on select items! Discount code: OVERSTOCK\" , :active => true ) Promotion . create! ( :name => \"Upsale\" , :call_to_action => \"Add another widget to your cart now for a 25% discount\" , :active => true ) Make sure to run rake db:seed to load the promotions into your database. Now let’s edit our Session model and add a method we can use to display the promotions to our site’s visitors: class Session < ActiveRecord :: SessionStore :: Session def flash ( id , msg ) data [ 'flash' ] ||= { 'flashes' => {}, 'discard' => [] } data [ 'flash' ][ 'flashes' ][ id . to_sym ] = msg end def display_promotion ( id , track = true ) viewed_promotions << id if track promotion = Promotion . find ( id ) flash :promotion , promotion . call_to_action end def viewed_promotions data [ 'viewed_promotions' ] ||= [] end end Go ahead and test that out now if you’d like. You should still have the Rails server and console running. Enter this into the console: reload! promotion = Promotion . all . sample Session . first . tap do | session | session . display_promotion ( promotion . id , false ) session . save! end Now refresh your browser, and you should see the promotion appear. Refresh it again, and it goes away as expected. Notice I set track to false for this example. This is because we don’t really want to start keeping track of the promotions while testing it out in the console. Otherwise we’d have to clear our session if we want to test it out more than once. Running the Promotions To run the promotions we can use a background processor. For this example I’ll be using the clockwork gem . Start by installing the gem: $ echo \"gem 'clockwork'\" >> Gemfile $ bundle Next, create a file called lib/promotions.rb and add the following content: require 'clockwork' require_relative '../config/boot' require_relative '../config/environment' module Clockwork every ( 1 . minute , 'random.promotions' ) { Session . all . each { | session | promotion = Promotion . all . sample next if session . viewed_promotions . include? ( promotion . id ) session . display_promotion ( promotion . id ) session . save! } } end I won’t go over this file in depth. If you’d like to know exactly how it works you can read the clockwork documentation. Basically what it does is display a random promotion to every visitor on your site every 1 minute. Run this command to try it out: $ bundle exec clockwork lib/promotions.rb Note that bundle exec is required in this case. The way clockwork functions, the promotion will be run immediately, and then every minute thereafter. Tracking Active Vistors By adding data to the sessions, we’re not actually targetting active visitors. The session could have been created days ago, and the visitor might not actually be on the site at the moment. So let’s fix that. Add the following code to app/controllers/application_controller.rb : before_action { session [ :last_seen_at ] = Time . now } We can now keep track of when the last time a visitor actually used the application. Let’s add a scope for this to the Session model: class Session < ActiveRecord :: SessionStore :: Session scope :active , lambda { all . select ( & :active? ) } def active? data [ 'last_seen_at' ] && data [ 'last_seen_at' ] > 1 . minute . ago end end Now we can update our clockwork process to target only the active visitors: require 'clockwork' require_relative '../config/boot' require_relative '../config/environment' module Clockwork every ( 1 . minute , 'random.promotions' ) { Session . active . each { | session | promotion = Promotion . all . sample next if session . viewed_promotions . include? ( promotion . id ) session . display_promotion ( promotion . id ) session . save! } } end Conclusion This method allows you to push data to your users’ sessions. Alternatively, you could do the same exact thing by adding a few more columns to the Promotion model, and some code to the ApplicationController . It would be much simpler, as you wouldn’t need a background process, however, you’d be pulling the data instead of pushing it. What’s the difference between pushing and pulling data? The difference is that the server is directly communicating with your users when you push data. This opens up a lot of possibilities. For example, if you wanted to put your server into maintenance mode, you could have a process that you can run to let all of your site’s active visitors know that you’re about to shut them down. For example. Add a bin/maintenance file to the application with the following code: #!/usr/bin/env ruby APP_PATH = File . expand_path ( '../../config/application' , __FILE__ ) require_relative '../config/boot' require_relative '../config/environment' ttl = 30 until ttl == 0 do puts \" #{ ttl } \" Session . active . each { | session | session . flash :alert , \"Server shutting down in #{ ttl } seconds.\" session . save } sleep ( 1 ) ttl -= 1 end Session . active . each { | session | # clear flash messages so visitors don't # see the last one next time they sign on session . data [ 'flash' ] = nil session . save } Then make it an executable: $ chmod +x bin/maintenance Now your site’s active visitors will have a nice timed warning the next time you go to shut down the server. All you have to do is run bin/maintenance before you shut it down. To accomplish the same task via pulling data from the server would be considerably more complex, as you can imagine. "}]}